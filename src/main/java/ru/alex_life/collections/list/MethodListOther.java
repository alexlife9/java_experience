package ru.alex_life.collections.list;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * Теория. Интерфейс List
 * В этом уроке мы познакомимся со структурой данных – список, который описывается интерфейсом List.
 * В такой структуре в определенной последовательности хранятся элементы одного типа.
 * Очень важная особенность данной структуры – мы всегда можем пронумеровать элементы списка,
 * т.е. проводя аналогию с массивом – у каждого элемента есть свой индекс.
 * Если проводить параллель из жизни – у нас есть, к примеру, склад строительных материалов,
 * на котором пронумерованы стеллажи, и чтобы не бегать по всему складу сотрудники необходимое могут найти по номеру.
 * При этом у нас может быть один и тот же материал, но разного производителя, т.е. одинаковые элементы.
 *
 * Самым важным для работы с коллекциями является набор CRUD – операций которые мы можем с ними сделать
 * (CRUD – сокращение от слов create, read, update and delete).
 * Т.е. нас в первую очередь интересует набор методов, которые объявлены в интерфейсе List<E> и как они работают.
 * Для рассмотрения будем использовать средства обобщенного программирования, т.е. везде используем generics,
 * вместо E в объявлении интерфейса может быть определен любой тип ссылочных данных.
 *
 * @author Alex_life
 * @version 1.0
 * @since 01.11.2021
 */
public class MethodListOther {
    public static void main(String[] args) {
        //Ряд методов, которые определены в интерфейсе List<E> и находят широкое применение:
        //1. boolean contains(E element)** – метод возвращает true, если список содержит переданный в метод элемент element.
        List<String> rsl = new ArrayList<>();
        rsl.add("one");
        rsl.add("two");
        rsl.add("three");
        boolean b = rsl.contains("two");
        boolean c = rsl.contains("twoo");
        System.out.println("Список содержит искомый элемент: " + b);
        System.out.println("Список содержит искомый элемент: " + c);
        System.out.println();

        //2. int indexOf(E element)** – метод возвращает индекс элемента element при его первом вхождении в список.
        // Если элемент не найден - метод возвращает -1.
        int i = rsl.indexOf("two");
        int i1 = rsl.indexOf("twoo");
        System.out.println("Индекс элемента в списке: " + i);
        System.out.println("Индекс элемента в списке: " + i1);
        System.out.println();

        //3. int lastIndexOf(E element)** - метод возвращает индекс элемента element при его последнем вхождении в список.
        // Если элемент не найден - метод возвращает -1.
        rsl.add("one");
        int i2 = rsl.lastIndexOf("one"); //добавили еще один элемент, т.е. дубликат и будем искать его индекс
        System.out.println("Индекс дубликата элемента в списке: " + i2);
        System.out.println();

        //4. int size() - метод возвращает целочисленное значение, и говорит нам о том, сколько элементов находится в списке.
        int size = rsl.size();
        System.out.println("Сейчас размер списка равен: " + size);
        System.out.println();

        //5. List<E> subList(int fromIndex, int toIndex) - метод возвращает список, который содержит все элементы исходного списка
        // начиная с индекса fromIndex(включительно) и до toIndex(значение исключается).
        // При этом, если выполняется условие fromIndex == toIndex, то метод вернет пустой список.
        List<String> list = rsl.subList(0, 4);
        for (String s : list) {
            System.out.println("Элементы в границах указанных индексов: " + s);
        }
        System.out.println();

        //6. default void sort(Comparator<? super E> comp) – метод осуществляет сортировку списка в соответствии
        // с компаратором comp, который мы передаем в метод.
        list.sort(Comparator.naturalOrder());
        for (String s : list) {
            System.out.println("Сортируем список с помощью переданного компаратора: " + s);
        }
        System.out.println();
        list.sort(Comparator.reverseOrder());
        for (String s : list) {
            System.out.println("Сортируем список компаратором в обратном порядке: " + s);
        }
        //Отмеченные (**) методы реализованы с помощью цикла for(), поэтому применять эти методы внутри циклов,
        // которые перебирают список, нежелательно, поскольку так мы будем проходить по одному и тому же списку дважды.
    }
}
