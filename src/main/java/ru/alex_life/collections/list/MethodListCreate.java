package ru.alex_life.collections.list;
import java.util.ArrayList;
import java.util.List;

/**
 * Теория. Интерфейс List
 * В этом уроке мы познакомимся со структурой данных – список, который описывается интерфейсом List.
 * В такой структуре в определенной последовательности хранятся элементы одного типа.
 * Очень важная особенность данной структуры – мы всегда можем пронумеровать элементы списка,
 * т.е. проводя аналогию с массивом – у каждого элемента есть свой индекс.
 * Если проводить параллель из жизни – у нас есть, к примеру, склад строительных материалов,
 * на котором пронумерованы стеллажи, и чтобы не бегать по всему складу сотрудники необходимое могут найти по номеру.
 * При этом у нас может быть один и тот же материал, но разного производителя, т.е. одинаковые элементы.
 *
 * Самым важным для работы с коллекциями является набор CRUD – операций которые мы можем с ними сделать
 * (CRUD – сокращение от слов create, read, update and delete).
 * Т.е. нас в первую очередь интересует набор методов, которые объявлены в интерфейсе List<E> и как они работают.
 * Для рассмотрения будем использовать средства обобщенного программирования, т.е. везде используем generics,
 * вместо E в объявлении интерфейса может быть определен любой тип ссылочных данных.
 *
 * @author Alex_life
 * @version 1.0
 * @since 01.11.2021
 */
public class MethodListCreate {
    public static void main(String[] args) {
        //CREATE - Для добавления новых элементов предназначены 4 метода:
        //1. boolean add(E e) – добавляет элемент e в конец списка.
        List<String> rsl1 = new ArrayList<>();
        rsl1.add("one");
        rsl1.add("two");
        rsl1.add("three");
        for (String s : rsl1) {
            System.out.println("Первый метод добавления: " + s);
        }
        System.out.println();

        //2. void add(int index, E element) – добавляет указанный элемент (element) в указанную позицию (index) в списке.
        //При этом сдвигает элемент, который находится в этой позиции (если есть), и все последующие элементы вправо.
        List<String> rsl2 = new ArrayList<>();
        rsl2.add("one");
        rsl2.add("two");
        rsl2.add("three");
        rsl2.add(1, "four"); // второй метод - вставляем элемент во вторую ячейку
        for (String s : rsl2) {
            System.out.println("Второй метод добавления: " + s);
        }
        System.out.println();

        //3. boolean addAll(Collection<? extends E> c) – добавляет все элементы из переданной коллекции
        // в конец списка в том порядке, в котором они возвращаются итератором переданной коллекции.
        List<String> rsl3 = new ArrayList<>();
        List<String> list = new ArrayList<>();
        rsl3.add("one");
        rsl3.add("two");
        rsl3.add("three");
        list.add("four"); //третий метод - объединяем коллекции
        list.add("five");
        rsl3.addAll(list); //третий метод - объединяем коллекции
        for (String s : rsl3) {
            System.out.println("Третий метод добавления: " + s);
        }
        System.out.println();

        //4. boolean addAll(int index, Collection<? extends E> col) – добавляет все элементы из коллекции col
        // в список в указанную позицию (index). При этом сдвигает элемент, который находится в этой позиции,
        // и все последующие элементы вправо. Добавляемые элементы будут расставлены в том порядке,
        // в котором они возвращены итератором переданной коллекции.
        List<String> rsl4 = new ArrayList<>();
        List<String> list2 = new ArrayList<>();
        rsl4.add("one");
        rsl4.add("two");
        rsl4.add("three");
        list2.add("four");
        list2.add("five");
        rsl4.addAll(2, list2); //четвертый метод - объединяем коллекции с помощью вставки по индексу
        //Очень важно отметить, что добавление по индексу может бросить исключение класса IndexOutOfBoundsException,
        // если будет выполнено условие index < 0 || index > size().
        for (String s : rsl4) {
            System.out.println("Четвертый метод добавления: " + s);
        }
        System.out.println();

        //5. Также для создания и одновременного заполнения списка можно использовать фабричный метод of():
        //List<E> of(E ... elements) - метод возвращает список, в которые помещены список элементов elements типа E.
        //Метод принимает переменное количество аргументов (обозначается ...).
        //Т.е. мы можем перечислять большое количество конечных аргументов через запятую.
        //Поскольку количество аргументов задано изначально, то Очень важно понимать,
        // что метод возвращает неизменяемый список, т.е. вызвать метод add(), remove() и т.п. на такой коллекции не получится,
        // будет сгенерировано исключение UnsupportedOperationException.
        List<String> rsl5 = List.of("one", "two", "three");
        for (String s : rsl5) {
            System.out.println("Пятый метод добавления: " + s);
        }
        System.out.println();
    }
}
